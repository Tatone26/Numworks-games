paramètres:
    - difficulté
    - dark mode ??
+ ajout de règles (menu ??) ??

placed_cards = [[]*7] -> terrain
final_stacks = [[]*4] -> piles à compléter
deck = [] + position dans le deck (des cartes retournées) # TODO

1 2 3 4    5  6
7 8 9 10 11 12 13


# TECHNIQUE

class Card:
    numéro, suit, pos
-> def set_table(): crée le deck, mélange, place les cartes comme il faut
boucle principale :
    un curseur qui se déplace avec les flèches. En appuyant sur OK : - sélectionne une carte (ou plusieurs si il faut)
                                                    - place une carte si possible
                                                    - fait tourner le deck si placé sur le deck
                               En appuyant sur EXE : - déselectionne tout.
    Il faut donc : - une variable contenant la/les cartes sélectionnées. [[]*x]

    - sélectionne une ou plusieurs cartes : ez
    - pose une ou plusieurs cartes : vérifier uniquement dernière/première carte de la sélection. Faire confiance à la sélection pour le reste.
    - faire tourner le deck : déplace le "curseur interne" de difficulty cartes. Si finit, alors tout retourner.

# GRAPHIQUE
def draw_card(card, pos, outline=black, outline_size=1)

def get_abs_pos_from_pos(pos: int) -> (int, int):
    get_stack_from_pos -> trouver index de la carte -> renvoyer position absolue.
    renvoie la position sur l'écran correspondant à la position donnée

def get_stack_from_pos

def draw_selection(pos, selection_size):
    for i in reversed(range(selection_size)):
        draw_card selected  # Pas optimisé mais efficace niveau code. Si la calculatrice pas fonctionner alors changer.


# LETS GO CAUCHEMAR PLEUREEEEEER